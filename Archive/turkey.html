<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
<title>Turkey Survey Charts</title>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<script src="libraries/jquery-1.8.3.min.js"></script>
<script src="libraries/d3.tip.v0.6.3.js"></script>
<link rel="stylesheet" href="libraries/tool-tip-style.css">
<link rel="stylesheet" href="libraries/main.css">
<script src="http://d3js.org/topojson.v1.min.js"></script>
<style>

</style>
</head>

<body>
	<div id="main">
		<div class='controls'>
			<form action="">
				<input type="radio" name="mapLevel" value=1>Nuts 1
				<input type="radio" name="mapLevel" value=2 checked="checked">Nuts 2
				<input type="radio" name="mapLevel" value=3>Nuts 3
			</form>
		</div>
		<div id="mapContainer"></div>
		<div id="panelContainer"></div>
	</div>
</body>

<script>

//DATA PROCESSING FUNCTIONS
function processData(data) {
	function deString(d) {
		if (d==="") {
			return NaN;
		} else {
			return +d;
		}
	}
	var array = {
		regionCode: data.regionCode,
		groupID: deString(data.groupID),
		indicatorID: deString(data.indicatorID),
		sampleSize: deString(data.N),
		value: deString(data.value)
	}
	return array
}
function processGroups(data) {
	function deString(d) {
		if (d==="") {
			return NaN;
		} else {
			return +d;
		}
	}
	var array = {
		mainGroup: data.mainGroup,
		groupID: deString(data.groupID),
		subGroup: data.subGroup
	}
	return array
}


function setBins(max,min) {// calculates the bins for the color domain in the map
	var bounds = [];
	for (var i=1;i<=5;i++) { // create 5 equally sized bins between min*.95 and max*1.05
		bounds.push(min*.95+(((max*1.05)-(min*.95))*(i/5)));
	}
	return bounds;
}
function uniq_fast(a) { // quickly drop duplicate values from an array
	var seen = {};
	var out = [];
	var len = a.length;
	var j = 0;
	for(var i = 0; i < len; i++) {
	   var item = a[i];
		if(seen[item] !== 1) {
		    seen[item] = 1;
		    out[j++] = item;
		}
	}
	return out;
}


queue()
	.defer(d3.json, "maps/nuts1.json") //the zone map
	.defer(d3.json, "maps/nuts2.json")
	.defer(d3.json, "maps/nuts3.json")
	.defer(d3.csv, "data/nutsData.csv", processData)
	.defer(d3.csv, "data/groups.csv", processGroups)
	.await(ready);

function ready(error, mapFile1, mapFile2, mapFile3, nutsData, groups){
	drawMap(mapFile1, mapFile2, mapFile3, nutsData)
	drawPanel(nutsData, groups)
}


function drawMap(mapFile1, mapFile2, mapFile3, nutsData, groups){
	//THE FUNCTION THAT ADDS THE INDICATOR DATA TO THE MAP
	function addInditoMap(data, mapFeatures) {
		for (i = 0; i < data.length; i++) {
			var value = data[i].value;
			var regionCode = data[i].regionCode

			var feature = mapFeatures.filter(function(d) { return d.properties.adminLevel === regionCode;})
			if (feature.length > 0) {feature[0].properties.value = value}
		}
		return mapFeatures;
	}


	//CREATING THE CANVAS
	var mapContainerSize = d3.select('#mapContainer').node().getBoundingClientRect()
  	var mapMargin = {top: 0.008 * mapContainerSize.height , right: 0.008 * mapContainerSize.width, bottom: 0.008 * mapContainerSize.height, left: 0.008 * mapContainerSize.width};
  	var mapWidth = mapContainerSize.width - mapMargin.right - mapMargin.left; //Chart width
  	var mapHeight = mapContainerSize.height - mapMargin.top - mapMargin.bottom; //Chart height

  	var map = d3.select('#mapContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: mapHeight + mapMargin.top + mapMargin.bottom,
          width: mapWidth + mapMargin.left + mapMargin.right
        })
        .attr("id", "mapSvg")
      	.attr("transform", "translate(" + (mapMargin.left) + "," + (mapMargin.top)+ ")")//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //GET THE DATA READY
    var indicator = 4
    var group = 2
    var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
    var filteredData = nutsData.filter(function(d) {return d.indicatorID === indicator && d.regionCode.length === (nutsLevel + 2) && d.groupID === group})

	var max = d3.max(filteredData, function(d) { return d.value; });
	var min = d3.min(filteredData, function(d) { return d.value; });

	var bounds = setBins(max,min);

	var colorArray = ['rgb(255,51,51)','rgb(200,30,100)','rgb(130,15,150)','rgb(60,5,200)','rgb(0,0,255)'];
	colorArray.reverse();

	var color = d3.scale.threshold()
		.domain(bounds)
		.range(colorArray);

	//GETTING THE MAP DATA READY
	var mapFile = mapFile2
	var mapKey = Object.keys(mapFile.objects)//Pulls out the key associated with the map features
	var mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features
	// var test3 = uniq_fast(mapFeatures.map(function (d) {return d.LEVEL2_COD}))
	// var test2 = mapFeatures.filter(function (d) {return d.LEVEL2_COD === test[0]})
	mapFeatures = addInditoMap(filteredData, mapFeatures)
	console.log(mapFeatures)

	//SETTING THE MAP PROJECTION AND PATH
	var mapProjection = d3.geo.mercator()
		.scale(800) //(d3.min([2.5*mapWidth,2*mapHeight]))
		.translate([-0.15*mapWidth, 4.15*mapHeight])

	var mapPath = d3.geo.path()
		.projection(mapProjection)

	//DRAWING THE MAP
	var turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
		.data(mapFeatures)
		.enter()
		.append('path')
		.attr({
			d: mapPath,
			'class': 'turkeyMap',
			fill: function (d) {return color(d.properties.value)}
		});

		//turkey map .style create a function if d.id = AT_~

	//DRAWING BOUNDARIES
	var internalBoundaries = map.append("path") //the zonal boundaries
		.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		.attr({
			d: mapPath,
			class: 'country-boundary'
		});

	//LISTEN TO THE RADIO BUTTON AND REDRAW MAP BASED ON CLICKS
	$('input:radio').on('click', function(e) {
		if(e.currentTarget.name === "mapLevel"){
			var nutsLevel = Number(e.currentTarget.value);
			console.log(nutsLevel)
			//$( "#mapContainer" ).empty()
			if (nutsLevel === 1) {
				mapFile = mapFile1
			} else if (nutsLevel === 2) {
				mapFile = mapFile2
			} else {
				mapFile = mapFile3
			}
		}
		redrawMapNUTS(mapFile, nutsData)

	});
	function redrawMapNUTS(mapFile, nutsData){
		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
		filteredData = nutsData.filter(function(d) {return d.indicatorID === indicator && d.regionCode.length === (nutsLevel + 2) && d.groupID === group})
		//var test = uniq_fast(filteredData.map(function (d) {return d.regionCode})).sort()
		max = d3.max(filteredData, function(d) { return d.value; });
		min = d3.min(filteredData, function(d) { return d.value; });
		bounds = setBins(max,min);
		color.domain(bounds)


		mapKey = Object.keys(mapFile.objects)
		mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features

		//var test2 = uniq_fast(mapFeatures.map(function (d) {return d.properties.adminLevel})).sort()
		//console.log(test, test2)
		mapFeatures = addInditoMap(filteredData, mapFeatures)

		turkeyMap.remove()
		turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
			.data(mapFeatures)
			.enter()
			.append('path')
			.attr({
				d: mapPath,
				'class': 'turkeyMap',
				fill: function (d) {return color(d.properties.value)}
			});

		internalBoundaries.remove()
		internalBoundaries = map.append('path')
		internalBoundaries.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		internalBoundaries.attr({
				d: mapPath,
				class: 'country-boundary'
			});
	}
}

function drawPanel(nutsData, groups) {
	//HELPER FUNCTION FOR GETTING DATA INTO GROUPS
	function groupData(nutsData, groups, indicator, region) {
		var data = nutsData.filter(function (d) {return d.indicatorID === indicator && d.regionCode === region})
		var array = []
		groups.forEach(function(d) {
			var value = data.filter(function(e){return e.groupID === d.groupID})[0].value
			array.push({
				mainGroup: d.mainGroup,
				subGroup: d.subGroup,
				value: value
			})
		})
		return array
	}

	//GET THE DATA READY
	var indicator = 4 //this is changed only when the indicator is changed
	var region = 'TR' //the initial selection is for the country since thats the default representation
	var groupedData = groupData(nutsData, groups, indicator, region)
	console.log(groupedData)
	//GET THE CANVAS READY
	var panelContainerSize = d3.select('#panelContainer').node().getBoundingClientRect()
  	var panelMargin = {top: 0.008 * panelContainerSize.height , right: 0.08 * panelContainerSize.width, bottom: 0.008 * panelContainerSize.height, left: 0.008 * panelContainerSize.width};
  	var panelWidth = panelContainerSize.width - panelMargin.right - panelMargin.left; //Chart width
  	var panelHeight = panelContainerSize.height - panelMargin.top - panelMargin.bottom; //Chart height

  	var panel = d3.select('#panelContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: panelHeight + panelMargin.top + panelMargin.bottom,
          width: panelWidth + panelMargin.left + panelMargin.right
        })
        .attr("id", "panelSvg")
      	.attr("transform", "translate(" + (panelMargin.left) + "," + (panelMargin.top)+ ")")//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //GET THE SCALES AND CHARTING FUNCTIONS READY
    var maxValue = d3.max(groupedData, function(d) {return d.value})
    var minValue = d3.min(groupedData, function(d) {return d.value})
    var xScale = d3.scale.linear() //the xScale is set based on the values of the indicator
    	.domain([maxValue, minValue])
    	.range([0, panelWidth])

   	var yDomain = uniq_fast(groups.map(function(d) {return d.mainGroup}))
    var yScale = d3.scale.ordinal() //based on the number of mainGroups in the groups csv
    	.domain(yDomain)
    	.rangeBands([60, panelHeight], 0.1) //the range band fixes a margin of 60 for the first line

    //DRAW ELEMENTS ON THE PANEL
    var horizontalLines = panel.append('g')//thin lines to act as guides for the dots
    	.selectAll('.horizontalLines')
    	.data(yDomain)
    	.enter()
    	.append('line')
    	.attr({
    		x1: xScale(minValue),
    		y1: function(d) {return yScale(d)},
    		x2: xScale(maxValue),
    		y2: function(d) {return yScale(d)}
    	})
    	.style('stroke', 'black')

    var circles = panel.append('g')// dots of equal radius based on the value of the indicator placed based on the grouping
    	.selectAll('.dots')
    	.data(groupedData)
    	.enter()
    	.append('circle')
    	.attr({
    		cx: function(d) {return xScale(d.value)},
    		cy: function(d) {return yScale(d.mainGroup)},
    		r: 5
    	})
    


}


</script>
</html>
