<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
<title>Turkey Survey Charts</title>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<script src="libraries/jquery-1.8.3.min.js"></script>
<script src="libraries/d3.tip.v0.6.3.js"></script>
<link rel="stylesheet" href="libraries/tool-tip-style.css">
<link rel="stylesheet" href="libraries/main.css">
<script src="http://d3js.org/topojson.v1.min.js"></script>
<style>

</style>
</head>

<body>
	<div id="main">
		<div class='controls'>
			<div id = "dropDown">
				<select id= "indicatorList"></select>
			</div>
			<form action="">
				<input type="radio" name="mapLevel" value=1>Nuts 1
				<input type="radio" name="mapLevel" value=2 checked="checked">Nuts 2
				<input type="radio" name="mapLevel" value=3>Nuts 3
			</form>
		</div>
		<div id="mapContainer"></div>
		<div id="panelContainer"></div>
	</div>
</body>

<script>

//DATA PROCESSING FUNCTIONS
function deString(d) {
	if (d==="") {
		return NaN;
	} else {
		return +d;
	}
}
function processData(data) {
	var array = {
		regionCode: data.regionCode,
		groupID: deString(data.groupID),
		indicatorID: deString(data.indicatorID),
		sampleSize: deString(data.N),
		value: deString(data.value)
	}
	return array
}
function processGroups(data) {
	var array = {
		mainGroup: data.mainGroup,
		groupID: deString(data.groupID),
		subGroup: data.subGroup
	}
	return array
}
function processIndicators(data) {
	var array = {
		topic: data.topic,
		indicator: data.indicator,
		indicatorID: deString(data.indicatorID)
	}
	return array
}


function setBins(max,min) {// calculates the bins for the color domain in the map
	var bounds = [];
	for (var i=1;i<=5;i++) { // create 5 equally sized bins between min*.95 and max*1.05
		bounds.push(min*.95+(((max*1.05)-(min*.95))*(i/5)));
	}
	return bounds;
}
function uniq_fast(a) { // quickly drop duplicate values from an array
	var seen = {};
	var out = [];
	var len = a.length;
	var j = 0;
	for(var i = 0; i < len; i++) {
	   var item = a[i];
		if(seen[item] !== 1) {
		    seen[item] = 1;
		    out[j++] = item;
		}
	}
	return out;
}


queue()
	.defer(d3.json, "maps/nuts1.json") //the zone map
	.defer(d3.json, "maps/nuts2.json")
	.defer(d3.json, "maps/nuts3.json")
	.defer(d3.csv, "data/nutsData.csv", processData)
	.defer(d3.csv, "data/groups.csv", processGroups)
	.defer(d3.csv, "data/indicators.csv", processIndicators)
	.await(ready);

function ready(error, mapFile1, mapFile2, mapFile3, nutsData, groups, indicators){
	draw(mapFile1, mapFile2, mapFile3, nutsData, groups, indicators)
}

function draw(mapFile1, mapFile2, mapFile3, nutsData, groups, indicators) {

											//FIRST WE DRAW THE MAPS
	//HELPER FUNCTIONs
	//TO ADD INDICATOR DATA TO THE MAP
	function addInditoMap(data, mapFeatures) {
		for (i = 0; i < data.length; i++) {
			var value = data[i].value;
			var regionCode = data[i].regionCode

			var feature = mapFeatures.filter(function(d) { return d.properties.adminLevel === regionCode;})
			if (feature.length > 0) {feature[0].properties.value = value}
		}
		return mapFeatures;
	}
	//TO FILTER DATA DURING TRIGGER EVENTS
	function dataFilter(nutsData, mapOrPanel) {//group is set to 2 for initial draw at national level for map hover/click select the appropriate regional id
    	var sel = document.getElementById('indicatorList'); //selecting the default based on current input
    	var currentIndicator = deString(sel.options[sel.selectedIndex].value)
   		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
   		if (mapOrPanel) { //for map we need all the nuts regions data at the aggregated grouping
   			return nutsData.filter(function(d) { return d.indicatorID === currentIndicator && d.regionCode.length === (nutsLevel + 2) && d.groupID === 2})
   		} else {// for panel we want disaggregated groups (so not 2) for one particular region selection with defaul of national
   			return nutsData.filter(function(d) { return d.indicatorID === currentIndicator && d.groupID !== 2})
   		}
   		
    }

	//CREATE THE INDICATOR LIST TO POPULATE THE DROPDOWN MENU BASED ON CURRENT TAB
		//TO-DO: Create an onclick event for clicks on new tabs to redraw the selection for indicators.
	var indicatorList = indicators.filter(function(d) {return d.topic === "Corruption"}) //topic is hardcoded currently, should be base on tab selected
	var select = d3.select('#indicatorList')
	select.selectAll('options')
		.data(indicatorList)
		.enter()
		.append('option')
		.attr('value', function(d) {return d.indicatorID})
		.text(function(d) {return d.indicator})


	//CREATE THE CANVAS
	var mapContainerSize = d3.select('#mapContainer').node().getBoundingClientRect()
  	var mapMargin = {top: 0.008 * mapContainerSize.height , right: 0.008 * mapContainerSize.width, bottom: 0.008 * mapContainerSize.height, left: 0.008 * mapContainerSize.width};
  	var mapWidth = mapContainerSize.width - mapMargin.right - mapMargin.left; //Chart width
  	var mapHeight = mapContainerSize.height - mapMargin.top - mapMargin.bottom; //Chart height

  	var map = d3.select('#mapContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: mapHeight + mapMargin.top + mapMargin.bottom,
          width: mapWidth + mapMargin.left + mapMargin.right
        })
        .attr("id", "mapSvg")
      	.attr("transform", "translate(" + (mapMargin.left) + "," + (mapMargin.top)+ ")")//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //SET THE DOMAINS AND RANGES
    var filteredData = dataFilter(nutsData, true) //mapOrPanel is set to trues

	var max = d3.max(filteredData, function(d) { return d.value; });
	var min = d3.min(filteredData, function(d) { return d.value; });
	var bounds = setBins(max,min);

	var colorArray = ['rgb(255,51,51)','rgb(200,30,100)','rgb(130,15,150)','rgb(60,5,200)','rgb(0,0,255)'];
	colorArray.reverse();

	var color = d3.scale.threshold()
		.domain(bounds)
		.range(colorArray);

	//GETTING THE MAP DATA READY
	var mapFile = mapFile2 //hardoded to use the nuts2 level as the default
	var mapKey = Object.keys(mapFile.objects)//Pulls out the key associated with the map features
	var mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features
	mapFeatures = addInditoMap(filteredData, mapFeatures)

	//SETTING THE MAP PROJECTION AND PATH
	var mapProjection = d3.geo.mercator()
		.scale(800) //(d3.min([2.5*mapWidth,2*mapHeight]))
		.translate([-0.15*mapWidth, 4.15*mapHeight])

	var mapPath = d3.geo.path()
		.projection(mapProjection)

	//DRAWING THE MAP
	var turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
		.data(mapFeatures)
		.enter()
		.append('path')
		.attr({
			d: mapPath,
			'class': 'turkeyMap',
			fill: function (d) {return color(d.properties.value)}
		})
		.on('mouseover', mouseoverRegion)
		.on('mouseout', mouseoutRegion);

		//turkey map .style create a function if d.id = AT_~

	//DRAWING BOUNDARIES
	var internalBoundaries = map.append("path") //the zonal boundaries
		.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		.attr({
			d: mapPath,
			class: 'country-boundary'
		});

	//REDRAW FUNCTION
		//To-Do: Create a single function that responds to all the trigger events
	function redrawMapNUTS(mapFile, nutsData){
		filteredData = dataFilter(nutsData, true)
		//var test = uniq_fast(filteredData.map(function (d) {return d.regionCode})).sort()
		max = d3.max(filteredData, function(d) { return d.value; });
		min = d3.min(filteredData, function(d) { return d.value; });
		bounds = setBins(max,min);
		color.domain(bounds)


		mapKey = Object.keys(mapFile.objects)
		mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features

		//var test2 = uniq_fast(mapFeatures.map(function (d) {return d.properties.adminLevel})).sort()
		//console.log(test, test2)
		mapFeatures = addInditoMap(filteredData, mapFeatures)

		turkeyMap.remove()
		turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
			.data(mapFeatures)
			.enter()
			.append('path')
			.attr({
				d: mapPath,
				'class': 'turkeyMap',
				fill: function (d) {return color(d.properties.value)}
			});

		internalBoundaries.remove()
		internalBoundaries = map.append('path')
		internalBoundaries.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		internalBoundaries.attr({
				d: mapPath,
				class: 'country-boundary'
			});
	}



											//THE NEXT SECTION DRAWS THE SIDE PANEL
	//HELPER FUNCTION FOR GETTING DATA INTO GROUPS
	function groupData(nutsData, groups, region) { //region specifies the regional specification for the groups (so national or a particular hovered/clicked region)
		var data = dataFilter(nutsData, false)
		var array = []
		groups.forEach(function(d) {
			var value = data.filter(function(e){return e.groupID === d.groupID && e.regionCode === region})[0].value
			array.push({
				mainGroup: d.mainGroup,
				subGroup: d.subGroup,
				value: value
			})
		})
		return array
	};
	
	//console.log(dataFilter(nutsData, false))
	//GET THE DATA INTO THE DIFFERENT GROUPS (HORIZ LINES) FOR THE SIDE PANEL
	var defaultRegion = "TR"
	var groupedData = groupData(nutsData, groups, defaultRegion); //the default region is set to national ("TR") for panel view
	
	//GET THE CANVAS READY
	var panelContainerSize = d3.select('#panelContainer').node().getBoundingClientRect();
  	var panelMargin = {top: 0.008 * panelContainerSize.height , right: 0.08 * panelContainerSize.width, bottom: 0.008 * panelContainerSize.height, left: 0.008 * panelContainerSize.width};
  	var panelWidth = panelContainerSize.width - panelMargin.right - panelMargin.left; //Chart width
  	var panelHeight = panelContainerSize.height - panelMargin.top - panelMargin.bottom; //Chart height

  	var panel = d3.select('#panelContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: panelHeight + panelMargin.top + panelMargin.bottom,
          width: panelWidth + panelMargin.left + panelMargin.right
        })
        .attr("id", "panelSvg")
      	.attr("transform", "translate(" + (panelMargin.left) + "," + (panelMargin.top)+ ")");//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //GET THE SCALES AND CHARTING FUNCTIONS READY
    var maxValue = d3.max(groupedData, function(d) {return d.value})
    var minValue = d3.min(groupedData, function(d) {return d.value})
    var xScale = d3.scale.linear() //the xScale is set based on the values of the indicator
    	.domain([maxValue, minValue])
    	.range([0, panelWidth]);

   	var yDomain = uniq_fast(groups.map(function(d) {return d.mainGroup}))
    var yScale = d3.scale.ordinal() //based on the number of mainGroups in the groups csv
    	.domain(yDomain)
    	.rangeBands([60, panelHeight], 0.1); //the range band fixes a margin of 60 for the first line

    //DRAW ELEMENTS ON THE PANEL
    var horizontalLines = panel.append('g')//thin lines to act as guides for the dots
    	.selectAll('.horizontalLines')
    	.data(yDomain)
    	.enter()
    	.append('line')
    	.attr({
    		x1: xScale(minValue),
    		y1: function(d) {return yScale(d)},
    		x2: xScale(maxValue),
    		y2: function(d) {return yScale(d)}
    	})
    	.style('stroke', 'black');

    var circles = panel.append('g')// dots of equal radius based on the value of the indicator placed based on the grouping
    	.selectAll('.dots')
    	.data(groupedData)
    	.enter()
    	.append('circle')
    	.attr({
    		cx: function(d) {return xScale(d.value)},
    		cy: function(d) {return yScale(d.mainGroup)},
    		r: 5
    	});

    //REDRAW FUNCTION FOR THE PANEL
    function redrawPanel(nutsData, groups, region){
    	groupedData = groupData(nutsData, groups, region)
    	maxValue = d3.max(groupedData, function(d) {return d.value})
    	minValue = d3.min(groupedData, function(d) {return d.value})
    	xScale.domain([maxValue, minValue])

    	circles = circles.data(groupedData)
    	circles.exit().remove()
    	circles.enter().append('circle')
    	circles.attr({
    		cx: function(d) {return xScale(d.value)},
    		cy: function(d) {return yScale(d.mainGroup)},
    		r: 5
    	});
    }



    									//LISTENERS FOR DIFFERENT TRIGGER EVENTS
	//1. CLICK ON THE RADIO BUTTONS: ONLY AFFECTS MAPS SINCE PANEL IS AFFECTED ONLY BY HOVER OR CLICK EVENTS ON MAP
	$('input:radio').on('click', function(e) {
		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
		if (nutsLevel === 1) {
			mapFile = mapFile1
		} else if (nutsLevel === 2) {
			mapFile = mapFile2
		} else {
			mapFile = mapFile3
		}
		redrawMapNUTS(mapFile, nutsData)
	});

	//2. A NEW INDICATOR SELECTION AFFECTS BOTH MAP AND PANEL
	d3.select('#indicatorList').on('change.line', function(d) {
		redrawMapNUTS(mapFile, nutsData);
		redrawPanel(nutsData, groups, defaultRegion) //region is reset to the national level (so clicked or hovered regions are wiped)
    });

	//3. MOUSE-HOVER ON REGION
	function mouseoverRegion(d) {
		var hoverRegion = d.properties.adminLevel;
		redrawPanel(nutsData, groups, hoverRegion)
	}

	function mouseoutRegion(d) {
		redrawPanel(nutsData, groups, defaultRegion)
	}

	function onClickRegion(d) {
		
	}
}



</script>
</html>
