<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
<title>Turkey Survey Charts</title>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<script src="libraries/jquery-1.8.3.min.js"></script>
<script src="libraries/d3.tip.v0.6.3.js"></script>
<link rel="stylesheet" href="libraries/tool-tip-style.css">
<link rel="stylesheet" href="libraries/main.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
<script src="http://d3js.org/topojson.v1.min.js"></script>
<style>
</style>
</head>

<body>
	<div id="main">
		<div class='controls'>
			<div id = "dropDown">
				<select id= "indicatorList"></select>
			</div>
		</div>
		<div id="mapContainer"></div>
		<div id="panelContainer"></div>
		<div id="legendAndButtons">
			<div id="legend"></div>
			<form action="">
				<input type="radio" name="mapLevel" value=1>Nuts 1
				<input type="radio" name="mapLevel" value=2 checked="checked">Nuts 2
				<input type="radio" name="mapLevel" value=3>Nuts 3
			</form>
		</div>

	</div>
</body>

<script>

//DATA PROCESSING FUNCTIONS
function processData(data) {
	var array = {
		regionCode: data.regionCode,
		groupID: deString(data.groupID),
		indicatorID: deString(data.indicatorID),
		sampleSize: deString(data.N),
		value: deString(data.value)
	}
	return array
}
function processGroups(data) {
	var array = {
		mainGroup: data.mainGroup,
		groupID: deString(data.groupID),
		subGroup: data.subGroup,
		symbol: data.symbols,
		fontSize: data.fontSize
	}
	return array
}
function processIndicators(data) {
	var array = {
		topic: data.topic,
		indicator: data.indicator,
		indicatorID: deString(data.indicatorID)
	}
	return array
}

//HELPER FUNCTIONS
function deString(d) {
	if (d==="") {
		return NaN;
	} else {
		return +d;
	}
}
function wrap(text, width) {
	text.each(function() {
	    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0, //<-- 0!
        lineHeight = 1.2, // ems
        x = text.attr("x"), //<-- include the x!
        y = text.attr("y"),
        dy = text.attr("dy") ? text.attr("dy") : 0; //<-- null check
        tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
        }
    });
}
function setBins(max,min) {// calculates the bins for the color domain in the map
	var bounds = [];
	for (var i=1;i<=5;i++) { // create 5 equally sized bins between min*.95 and max*1.05
		bounds.push(min*.95+(((max*1.05)-(min*.95))*(i/5)));
	}
	return bounds;
}
function uniq_fast(a) { // quickly drop duplicate values from an array
	var seen = {};
	var out = [];
	var len = a.length;
	var j = 0;
	for(var i = 0; i < len; i++) {
	   var item = a[i];
		if(seen[item] !== 1) {
		    seen[item] = 1;
		    out[j++] = item;
		}
	}
	return out;
}


queue()
	.defer(d3.json, "maps/nuts1.json") //the zone map
	.defer(d3.json, "maps/nuts2.json")
	.defer(d3.json, "maps/nuts3.json")
	.defer(d3.csv, "data/nutsData.csv", processData)
	.defer(d3.csv, "data/groupsWithSymbols.csv", processGroups)
	.defer(d3.csv, "data/indicators.csv", processIndicators)
	.await(ready);

function ready(error, mapFile1, mapFile2, mapFile3, nutsData, groups, indicators){
	draw(mapFile1, mapFile2, mapFile3, nutsData, groups, indicators)
}

function draw(mapFile1, mapFile2, mapFile3, nutsData, groups, indicators) {

											//FIRST WE DRAW THE MAPS
	//HELPER FUNCTIONs
	//TO ADD INDICATOR DATA TO THE MAP
	function addInditoMap(data, mapFeatures) {
		for (i = 0; i < data.length; i++) {
			var value = data[i].value;
			var regionCode = data[i].regionCode

			var feature = mapFeatures.filter(function(d) { return d.properties.adminLevel === regionCode;})
			if (feature.length > 0) {feature[0].properties.value = value;
				feature[0].properties.active = false;}
		}
		return mapFeatures;
	}
	//TO FILTER DATA DURING TRIGGER EVENTS
	function dataFilter(nutsData, mapOrPanel, groupID) {//group is set to 2 for initial draw at national level for map hover/click select the appropriate regional id
    	var sel = document.getElementById('indicatorList'); //selecting the default based on current input
    	var currentIndicator = deString(sel.options[sel.selectedIndex].value)
   		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
   		if (mapOrPanel) { //for map we need all the nuts regions data at the aggregated grouping
   			return nutsData.filter(function(d) { return d.indicatorID === currentIndicator && d.regionCode.length === (nutsLevel + 2) && d.groupID === groupID})
   		} else {// for panel we want disaggregated groups (so not 2) for one particular region selection with defaul of national
   			return nutsData.filter(function(d) { return d.indicatorID === currentIndicator && d.groupID !== 2})//fixing this to 2 since for panel that is the only value we will be using to filter
   		}
    }

	//CREATE THE INDICATOR LIST TO POPULATE THE DROPDOWN MENU BASED ON CURRENT TAB
		//TO-DO: Create an onclick event for clicks on new tabs to redraw the selection for indicators.
	var indicatorList = indicators.filter(function(d) {return d.topic === "Corruption"}) //topic is hardcoded currently, should be base on tab selected
	var select = d3.select('#indicatorList')
	select.selectAll('options')
		.data(indicatorList)
		.enter()
		.append('option')
		.attr('value', function(d) {return d.indicatorID})
		.text(function(d) {return d.indicator})


	//CREATE THE CANVAS
	var mapContainerSize = d3.select('#mapContainer').node().getBoundingClientRect()
  	var mapMargin = {top: 0.008 * mapContainerSize.height , right: 0.008 * mapContainerSize.width, bottom: 0.008 * mapContainerSize.height, left: 0.008 * mapContainerSize.width};
  	var mapWidth = mapContainerSize.width - mapMargin.right - mapMargin.left; //Chart width
  	var mapHeight = mapContainerSize.height - mapMargin.top - mapMargin.bottom; //Chart height

  	var map = d3.select('#mapContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: mapHeight + mapMargin.top + mapMargin.bottom,
          width: mapWidth + mapMargin.left + mapMargin.right
        })
        .attr("id", "mapSvg")
      	.attr("transform", "translate(" + (mapMargin.left) + "," + (mapMargin.top)+ ")")//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //SET THE DOMAINS AND RANGES
    	//To-Do: Come up with a better color range: http://christopheviau.com/d3list/gallery.html#visualizationType=choropleth
    var filteredData = dataFilter(nutsData, true, 2) //mapOrPanel is set to trues

	var max = d3.max(filteredData, function(d) { return d.value; });
	var min = d3.min(filteredData, function(d) { return d.value; });
	var bounds = setBins(max,min);

	var colorArray = ['rgb(241,238,246)','rgb(189,201,225)','rgb(116,169,207)','rgb(43,140,190)','rgb(4,90,141)']
	//colorArray.reverse();

	/*var color = d3.scale.threshold()
		.domain(bounds)
		.range(colorArray);*/
	var color = d3.scale.threshold()
    	.domain(bounds)
    	.range(colorArray);

	//GETTING THE MAP DATA READY
	var mapFile = mapFile2 //hardoded to use the nuts2 level as the default
	var mapKey = Object.keys(mapFile.objects)//Pulls out the key associated with the map features
	var mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features
	mapFeatures = addInditoMap(filteredData, mapFeatures)

	//SETTING THE MAP PROJECTION AND PATH
		//To-Do: Automatically center a map
	var mapProjection = d3.geo.mercator()
		.center([19.5,71.2])
		.scale(550)
		.rotate([0,0,5.5])
		.translate([mapWidth/2,mapHeight/2]);

	var mapPath = d3.geo.path()
		.projection(mapProjection)

	//DEFINING TOOL-TIPS
    var mapTip = d3.tip()
    	.attr('class', 'd3-tip')
    	.offset([10, 5])
      	.direction('e')
      	.html(function(d) {return "<strong>Name:</strong> <span style='color:silver'>" + d.properties.name + "</span>" + "<br>" +
      		"<strong>Value:</strong> <span style='color:silver'>" + d.properties.value + "</span>" })
    
	//DRAWING THE MAP
	var turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
		.data(mapFeatures)
		.enter()
		.append('path')
		.attr({
			d: mapPath,
			'class': 'turkeyMap',
			fill: function (d) {return color(d.properties.value)}
		})
		.style('cursor', 'pointer')
		.on('mouseover', mouseoverRegion)
		.on('mouseout', mouseoutRegion)
		.call(mapTip)
		//.on('click', onClickRegion);

	//DRAWING BOUNDARIES
		//To-Do: Different boundaries for different nuts levels 2. Country boundary 3. Active Boundary
	var internalBoundaries = map.append("path") //the zonal boundaries
		.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		.attr({
			d: mapPath,
			class: 'nuts-boundary'
		});

	var countryBoundary = map.append('path')
		.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) {return a === b}))
		.attr({
			d: mapPath,
			class: 'country-boundary'
		});

	//DRAW MAP LEGEND
	var legendContainerSize = d3.select('#legend').node().getBoundingClientRect()
	var rectWidth = legendContainerSize.width/color.range().length, rectHeight = legendContainerSize.height/2;
	console.log(rectWidth, rectHeight)
	var legend = d3.select('#legend').append('svg')
		.attr({
	          height: legendContainerSize.height,
	          width: legendContainerSize.width
	        })
	legend.append('g')
		.selectAll('rect')
		.data(color.range())
		.enter()
		.append('rect')
		.attr({
			x:function(d, i){return i * rectWidth},
			y: 0,
			height:rectHeight,
			width:rectWidth,
			fill: function(d){return d}
		})
		.style('stroke', 'white')
		.style('stroke-width', '0.6px')

	var legendText = bounds
	var legendLabels = legend.append('g')
		.selectAll('.legendLabels')
		.data(legendText)
		.enter()
		.append('text')
		.text(function(d){return Math.ceil(d)})
		.attr({
			x:function(d,i){return (i+1) * rectWidth},
			y: rectHeight +12,
			class: 'legendLabels'
		})
		
	//REDRAW FUNCTION
		//To-Do: Create a single function that responds to all the trigger events
	function redrawMapNUTS(mapFile, nutsData, groupID){
		filteredData = dataFilter(nutsData, true, groupID)
		//var test = uniq_fast(filteredData.map(function (d) {return d.regionCode})).sort()
		max = d3.max(filteredData, function(d) { return d.value; });
		min = d3.min(filteredData, function(d) { return d.value; });
		bounds = setBins(max,min);
		color.domain(bounds)


		mapKey = Object.keys(mapFile.objects)
		mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features
		mapFeatures = addInditoMap(filteredData, mapFeatures)

		turkeyMap.remove()
		turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
			.data(mapFeatures)
			.enter()
			.append('path')
			.attr({
				d: mapPath,
				'class': 'turkeyMap',
				fill: function (d) {return color(d.properties.value)}
			})
			.style('cursor', 'pointer')
			.on('mouseover', mouseoverRegion)
			.on('mouseout', mouseoutRegion)
			.call(mapTip)
			//.on('click', onClickRegion);

		internalBoundaries.remove()
		internalBoundaries = map.append('path')
		internalBoundaries.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		internalBoundaries.attr({
				d: mapPath,
				class: 'nuts-boundary'
			});
		countryBoundary.remove()
		countryBoundary = map.append('path')
		countryBoundary.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a === b}))
		countryBoundary.attr({
				d: mapPath,
				class: 'country-boundary'
			});
	}

/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

											//THE NEXT SECTION DRAWS THE SIDE PANEL
	//HELPER FUNCTION FOR GETTING DATA INTO GROUPS
	function groupData(nutsData, groups, region) { //region specifies the regional specification for the groups (so national or a particular hovered/clicked region)
		var data = dataFilter(nutsData, false, 2)
		var array = []
		groups.forEach(function(d) {
			var value = data.filter(function(e){return e.groupID === d.groupID && e.regionCode === region})[0].value
			array.push({
				mainGroup: d.mainGroup,
				subGroup: d.subGroup,
				groupID: d.groupID,
				value: value,
				symbol:d.symbol,
				fontSize: d.fontSize
			})
		})
		return array
	};

	//GET THE DATA INTO THE DIFFERENT GROUPS (HORIZ LINES) FOR THE SIDE PANEL
	var defaultRegion = "TR"
	var groupedData = groupData(nutsData, groups, defaultRegion); //the default region is set to national ("TR") for panel view

	//GET THE CANVAS READY
	var panelContainerSize = d3.select('#panelContainer').node().getBoundingClientRect();
  	var panelMargin = {top: 0.1 * panelContainerSize.height , right: 0.00008 * panelContainerSize.width, bottom: 0.008 * panelContainerSize.height, left: 0.15 * panelContainerSize.width};
  	var panelWidth = panelContainerSize.width - panelMargin.right - panelMargin.left; //Chart width
  	var panelHeight = panelContainerSize.height - panelMargin.top - panelMargin.bottom; //Chart height

  	var panel = d3.select('#panelContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: panelHeight + panelMargin.top + panelMargin.bottom,
          width: panelWidth + panelMargin.left + panelMargin.right
        })
        .attr("id", "panelSvg")
      	.attr("transform", "translate(" + (panelMargin.left) + "," + (panelMargin.top)+ ")");//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //GET THE SCALES AND CHARTING FUNCTIONS READY
    var maxValue = d3.max(groupedData, function(d) {return d.value})
    var minValue = d3.min(groupedData, function(d) {return d.value})
    var xScale = d3.scale.linear() //the xScale is set based on the values of the indicator
    	.domain([minValue, maxValue])
    	.range([panelMargin.left, panelWidth]);

   	var yDomain = uniq_fast(groups.map(function(d) {return d.mainGroup}))
    var yScale = d3.scale.ordinal() //based on the number of mainGroups in the groups csv
    	.domain(yDomain)
    	.rangeBands([60, panelHeight], 0.1); //the range band fixes a margin of 60 for the first line

    //CREATE THE X-AXIS
    var numberTicks = Math.floor((maxValue - minValue)/15); //shared with the grid
    var xAxis = d3.svg.axis()
    	.scale(xScale)
    	.orient('bottom')
    	.ticks(numberTicks)

    var xAxisLine = panel.append('g')
    	.attr('class', 'xAxis')
    	.call(xAxis)
    	.attr('transform', "translate(0, " + (panelHeight - panelMargin.top) + ")")
    	.style('cursor', 'default')

    //CREATE TOOLTIP
    	//Fine-tune the design for tooltip
    var symbolTip = d3.tip()
    	.attr('class', 'd3-tip')
    	.offset([10, 5])
      	.direction('e')
      	.html(function(d) {return "<strong class='symbols'; style = 'font-size:32px'>" + d.symbol +"</strong> <span>" +"   "+ d.subGroup + "</span>" + "<br>" +
      		"<strong style='color:silver'>Value:</strong> <span>" + d.value + "</span>"})

	//DRAW GRID
	var hGrid = panel.append('g')
		.selectAll('.hLines')
		.data(yDomain)
		.enter()
		.append('line')
		.attr({
			x1: xScale(minValue),
    		y1: function(d) {return yScale(d) - 6},
    		x2: xScale(maxValue),
    		y2: function(d) {return yScale(d) - 6},
    		class: 'hLines'
		})

	var vGrid = panel.append('g')
		.selectAll('.vLines')
		.data(xScale.ticks(numberTicks))
		.enter()
		.append('line')
		.attr({
			x1: function(d){return xScale(d)},
			y1: yScale(yDomain[0]),
			x2: function(d){return xScale(d)},
			y2: yScale(yDomain[4]),
			class: 'vLines'
		})

	//DRAW ELEMENTS ON THE PANEL
    	//To-Do: Address symbol overlap while hovering http://bl.ocks.org/lilyc5459/a35687613ab0f4991f37
    var symbols = panel.append('g')// dots of equal radius based on the value of the indicator placed based on the grouping
    	.selectAll('.symbols')
    	.data(groupedData)
    	.enter()
    	.append('text')
    	.html(function(d) {return d.symbol})
    	.attr({
    		x: function(d) {return xScale(d.value)},
    		y: function(d) {return yScale(d.mainGroup)},
    		class: 'symbols'
    	})
    	.style('font-size', function(d) {return d.fontSize + "px"})
    	.style('cursor', 'pointer')
    	.on('mouseover', mouseoverSymbol)
    	.on('mouseout', mouseoutSymbol)
    	.call(symbolTip);

   	//PREVENTING SYMBOL OVERLAP 
    	//To-Do: Apply this on symbol hover
/*	$(document).ready(function() {
		$(document).mousemove(function(event) {
			console.log(event.pageX);
			console.log(event.pageY);
		})
	})*/
/*    relax(6, 10)
    function relax(spacing, minGap) {
    	symbols.each(function(d, i){
    		a = this
    		group1 = d3.select(a).data()[0].mainGroup
    		xPosition1 = d3.select(a).attr('x')
    		yPosition1 = d3.select(a).attr('y')
    		symbols.each(function(e, j) {
    			b = this;
    			group2 = d3.select(b).data()[0].mainGroup
    			xPosition2 = d3.select(b).attr('x')
    			yPosition2 = d3.select(b).attr('y')
    			delta = xPosition1 - xPosition2
    			if(a != b && group1 === group2 && yPosition1 === yPosition2 && Math.abs(delta) < minGap) {
    				d3.select(a).transition().duration(2000).attr('y', + yPosition1 - spacing)
    				//d3.select(b).transition().duration(2000).attr('x', +xPosition2 - adjust)
    				return
    			}
    		})
    	})
    }*/

    //DRAW LABELS
    var yLabels = panel.append('g')
    	.selectAll('.yLabels')
    	.data(yDomain)
    	.enter()
    	.append('text')
    	.text(function(d) {return d})
    	.attr({
    		x: xScale(minValue) - 90,
    		y: function(d) {return yScale(d) - 6},
    		class: 'yLabels'
    	})
    	.style('cursor', 'default')
    	.call(wrap, 90)

    //REDRAW FUNCTION FOR THE PANEL
    function redrawPanel(nutsData, groups, region){
    	groupedData = groupData(nutsData, groups, region)
    	maxValue = d3.max(groupedData, function(d) {return d.value})
    	minValue = d3.min(groupedData, function(d) {return d.value})
    	xScale.domain([minValue, maxValue])

    	numberTicks = Math.ceil((maxValue - minValue)/15)
    	xAxis.ticks(numberTicks)
    	xAxisLine.call(xAxis)
    	vGrid = vGrid.data(xScale.ticks(numberTicks))
    	vGrid.exit().remove()
    	vGrid.enter().append('line')
    	vGrid.transition().duration(400).attr({
    		x1: function(d){return xScale(d)},
			y1: yScale(yDomain[0]),
			x2: function(d){return xScale(d)},
			y2: yScale(yDomain[4]),
			class: 'vLines'
    	})

    	symbols = symbols.data(groupedData)
    	symbols.exit().remove()
    	symbols.enter().append('text').html(function(d) {return d.symbol})
    	symbols.transition().duration(400).attr({
    		x: function(d) {return xScale(d.value)},
    		y: function(d) {return yScale(d.mainGroup)},
    		class: 'symbols'
    	})
    	symbols.style('font-size', function(d) {return d.fontSize + "px"})
    		.style('cursor', 'pointer')
    	symbols.on('mouseover', mouseoverSymbol)
    		.on('mouseout', mouseoutSymbol)
    		.call(symbolTip);
    }

/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/


    									//LISTENERS FOR DIFFERENT TRIGGER EVENTS
	//1. CLICK ON THE RADIO BUTTONS: ONLY AFFECTS MAPS SINCE PANEL IS AFFECTED ONLY BY HOVER OR CLICK EVENTS ON MAP
	$('input:radio').on('click', function(e) {
		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
		if (nutsLevel === 1) {
			mapFile = mapFile1
		} else if (nutsLevel === 2) {
			mapFile = mapFile2
		} else {
			mapFile = mapFile3
		}
		redrawMapNUTS(mapFile, nutsData, 2)
	});

	//2. A NEW INDICATOR SELECTION AFFECTS BOTH MAP AND PANEL
	d3.select('#indicatorList').on('change.line', function(d) {
		redrawMapNUTS(mapFile, nutsData, 2);
		redrawPanel(nutsData, groups, defaultRegion) //region is reset to the national level (so clicked or hovered regions are wiped)
    });

	//3. MOUSE-HOVER ON REGION
		//To-Do: Implement a smooth boundary transition that is attractive
	function mouseoverRegion(d) {
		var hoverRegion = d.properties.adminLevel;
		redrawPanel(nutsData, groups, hoverRegion)
		mapTip.show(d)
	}
	function mouseoutRegion(d) {
		redrawPanel(nutsData, groups, defaultRegion)
		mapTip.hide(d)
	}

	/*//4. MOUSE-CLICK ON REGION- implement only if necessary
		//To-Do: Execute an efficient and elegant toggle mechanism for clicked regions
	
	function onClickRegion(d) {
		if(d.properties.active) { //if the state is already active then toggle to nont-active
			d.properties.active = false;
		} else {
			d.properties.active = true;
		}
		console.log(d)
	}*/

	//5. PANEL DOT HOVER
	function mouseoverSymbol(d) {
		redrawMapNUTS(mapFile, nutsData, d.groupID)
		symbolTip.show(d)
	}

	function mouseoutSymbol(d) {
		redrawMapNUTS(mapFile, nutsData, 2)
		symbolTip.hide(d)
	}

}
	//Test: Automatically center map
/*	http://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
	var b = [], west, east, south, north, bWidth, bHeight;
	for(i = 0; i < mapFeatures.length; i++) {
		b.push(mapPath.bounds(mapFeatures[i]));
	}
	west = d3.max(b.map(function(d) {return d[0][0]}))
	east = d3.max(b.map(function(d) {return d[1][0]}))
	south = d3.max(b.map(function(d) {return d[0][1]}))
	north = d3.max(b.map(function(d) {return d[1][1]}))

	bWidth = Math.abs(east - west);
	bHeight = Math.abs(north - south);
	console.log(mapWidth, mapHeight, bWidth, bHeight)
	var s = 0.9/Math.max((bWidth/mapWidth), (bHeight/mapHeight))
	var t = [(mapWidth - (s * bWidth)) / 2, (mapHeight - (s * bHeight)) / 2]
	console.log(s, t)
	mapProjection
		.scale(s)
		.translate(t)*/


</script>
</html>
