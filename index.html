<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
<title>Turkey Survey Charts</title>
<script src="libraries/d3.v3.min.js"></script>
<script src="libraries/topojson.v1.min.js"></script>
<script src="libraries/queue.v1.min.js"></script>
<script src="libraries/jquery-1.8.3.min.js"></script>
<script src="libraries/d3.tip.v0.6.3.js"></script>
<link rel="stylesheet" href="libraries/tool-tip-style.css">
<link rel="stylesheet" href="libraries/main.css">
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">
<script src="http://d3js.org/topojson.v1.min.js"></script>
<style>
</style>
</head>

<body>
	<div id="main">
		<div id="mapControl">
			<div id = "dropDown">
				<select id= "indicatorList"></select>
			</div>
			<div id="mapContainer"></div>
			<div id="legendAndButtons">
				<div id="legend"></div>
				<form action="">
					<input type="radio" name="mapLevel" value=1>Nuts 1
					<input type="radio" name="mapLevel" value=2 checked="checked">Nuts 2
					<input type="radio" name="mapLevel" value=3>Nuts 3
				</form>
			</div>
		</div>
		<div id="panelContainer"></div>
	</div>
</body>

<script>

//DATA PROCESSING FUNCTIONS
function processData(data) {
	var array = {
		regionCode: data.regionCode,
		groupID: deString(data.groupID),
		indicatorID: deString(data.indicatorID),
		sampleSize: deString(data.N),
		value: deString(data.value)
	}
	return array
}
function processGroups(data) {
	var array = {
		mainGroup: data.mainGroup,
		groupID: deString(data.groupID),
		subGroup: data.subGroup,
		symbol: data.symbols,
		fontSize: data.fontSize
	}
	return array
}
function processIndicators(data) {
	var array = {
		topic: data.topic,
		indicator: data.indicator,
		indicatorID: deString(data.indicatorID)
	}
	return array
}

//HELPER FUNCTIONS
function deString(d) {
	if (d==="") {
		return NaN;
	} else {
		return +d;
	}
}
function wrap(text, width) {
	text.each(function() {
	    var text = d3.select(this),
        words = text.text().split(/\s+/).reverse(),
        word,
        line = [],
        lineNumber = 0, //<-- 0!
        lineHeight = 1.2, // ems
        x = text.attr("x"), //<-- include the x!
        y = text.attr("y"),
        dy = text.attr("dy") ? text.attr("dy") : 0; //<-- null check
        tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
        while (word = words.pop()) {
            line.push(word);
            tspan.text(line.join(" "));
            if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
            }
        }
    });
}
function setBins(max,min) {// calculates the bins for the color domain in the map
	var bounds = [];
	for (var i=1;i<=5;i++) { // create 5 equally sized bins between min*.95 and max*1.05
		bounds.push(min*.95+(((max*1.05)-(min*.95))*(i/5)));
	}
	return bounds;
}
function uniq_fast(a) { // quickly drop duplicate values from an array
	var seen = {};
	var out = [];
	var len = a.length;
	var j = 0;
	for(var i = 0; i < len; i++) {
	   var item = a[i];
		if(seen[item] !== 1) {
		    seen[item] = 1;
		    out[j++] = item;
		}
	}
	return out;
}


queue()
	.defer(d3.json, "maps/nuts1.json") //the zone map
	.defer(d3.json, "maps/nuts2.json")
	.defer(d3.json, "maps/nuts3.json")
	.defer(d3.csv, "data/nutsData.csv", processData)
	.defer(d3.csv, "data/groupsWithSymbols.csv", processGroups)
	.defer(d3.csv, "data/indicators.csv", processIndicators)
	.await(ready);

function ready(error, mapFile1, mapFile2, mapFile3, nutsData, groups, indicators){
	draw(mapFile1, mapFile2, mapFile3, nutsData, groups, indicators)
}

function draw(mapFile1, mapFile2, mapFile3, nutsData, groups, indicators) {

											//FIRST WE DRAW THE MAPS
	//HELPER FUNCTIONs
	//TO ADD INDICATOR DATA TO THE MAP
	function addInditoMap(data, mapFeatures) {
		for (i = 0; i < data.length; i++) {
			var value = data[i].value;
			var regionCode = data[i].regionCode
			if(uniq_fast(mapFeatures.map(function(d) {return d.properties.adminLevel})).indexOf(regionCode) === -1) console.log(regionCode)
			var feature = mapFeatures.filter(function(d) { return d.properties.adminLevel === regionCode;})
			console.log(feature.length)
			for(j = 0; j < feature.length; j++) {
				feature[j].properties.value = value;
			}
		}
		return mapFeatures;
	}
	//TO FILTER DATA DURING TRIGGER EVENTS
	function dataFilter(nutsData, mapOrPanel, groupID) {//group is set to 2 for initial draw at national level for map hover/click select the appropriate regional id
    	var sel = document.getElementById('indicatorList'); //selecting the default based on current input
    	var currentIndicator = deString(sel.options[sel.selectedIndex].value)
   		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
   		if (mapOrPanel) { //for map we need all the nuts regions data at the aggregated grouping
   			return nutsData.filter(function(d) { return d.indicatorID === currentIndicator && d.regionCode.length === (nutsLevel + 2) && d.groupID === groupID})
   		} else {// for panel we want disaggregated groups (so not 2) for one particular region selection with defaul of national
   			return nutsData.filter(function(d) { return d.indicatorID === currentIndicator && d.groupID !== 2})//fixing this to 2 since for panel that is the only value we will be using to filter
   		}
    }

	//CREATE THE INDICATOR LIST TO POPULATE THE DROPDOWN MENU BASED ON CURRENT TAB
		//TO-DO: Create an onclick event for clicks on new tabs to redraw the selection for indicators.
	var indicatorList = indicators.filter(function(d) {return d.topic === "Corruption"}) //topic is hardcoded currently, should be base on tab selected
	var select = d3.select('#indicatorList')
	select.selectAll('options')
		.data(indicatorList)
		.enter()
		.append('option')
		.attr('value', function(d) {return d.indicatorID})
		.text(function(d) {return d.indicator})


	//CREATE THE CANVAS
	var mapContainerSize = d3.select('#mapContainer').node().getBoundingClientRect()
  	var mapMargin = {top: 0.008 * mapContainerSize.height , right: 0.008 * mapContainerSize.width, bottom: 0.008 * mapContainerSize.height, left: 0.008 * mapContainerSize.width};
  	var mapWidth = mapContainerSize.width - mapMargin.right - mapMargin.left; //Chart width
  	var mapHeight = mapContainerSize.height - mapMargin.top - mapMargin.bottom; //Chart height

  	var map = d3.select('#mapContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: mapHeight + mapMargin.top + mapMargin.bottom,
          width: mapWidth + mapMargin.left + mapMargin.right
        })
        .attr("id", "mapSvg")
      	.attr("transform", "translate(" + (mapMargin.left) + "," + (mapMargin.top)+ ")")//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //SET THE DOMAINS AND RANGES
    	//To-Do: Come up with a better color range: http://christopheviau.com/d3list/gallery.html#visualizationType=choropleth
    var filteredData = dataFilter(nutsData, true, 2) //mapOrPanel is set to trues

	var max = d3.max(filteredData, function(d) { return d.value; });
	var min = d3.min(filteredData, function(d) { return d.value; });
	var bounds = setBins(max,min);

	var colorArray = ['rgb(241,238,246)','rgb(189,201,225)','rgb(116,169,207)','rgb(43,140,190)','rgb(4,90,141)']
	//colorArray.reverse();

	/*var color = d3.scale.threshold()
		.domain(bounds)
		.range(colorArray);*/
	var color = d3.scale.threshold()
    	.domain(bounds)
    	.range(colorArray);

	//GETTING THE MAP DATA READY
	var mapFile = mapFile2 //hardoded to use the nuts2 level as the default
	var mapKey = Object.keys(mapFile.objects)//Pulls out the key associated with the map features
	var mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features
	mapFeatures = addInditoMap(filteredData, mapFeatures)

	//SETTING THE MAP PROJECTION AND PATH
		//To-Do: Automatically center a map
	var mapProjection = d3.geo.mercator()
		.center([19.5,72.7])
		.scale(550)
		.rotate([0,0,5.5])
		.translate([mapWidth/2,mapHeight/2]);

	var mapPath = d3.geo.path()
		.projection(mapProjection)

	//DEFINING TOOL-TIPS
    var mapTip = d3.tip()
    	.attr('class', 'd3-tip')
    	.offset([10, 5])
      	.direction('e')
      	.html(function(d) {return "<strong>Name:</strong> <span style='color:silver'>" + d.properties.name + "</span>" + "<br>" +
      		"<strong>Value:</strong> <span style='color:silver'>" + d.properties.value + "</span>" })
    
	//DRAWING THE MAP
	var turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
		.data(mapFeatures)
		.enter()
		.append('path')
		.attr({
			d: mapPath,
			'class': 'turkeyMap',
			fill: function (d) {return color(d.properties.value)}
		})
		.style('cursor', 'pointer')
		.on('mouseover', mouseoverRegion)
		.on('mouseout', mouseoutRegion)
		.call(mapTip)
		//.on('click', onClickRegion);

	//DRAWING BOUNDARIES
		//To-Do: Different boundaries for different nuts levels 2. Country boundary 3. Active Boundary
	var internalBoundaries = map.append("path") //the zonal boundaries
		.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		.attr({
			d: mapPath,
			class: 'nuts-boundary'
		});

	var countryBoundary = map.append('path')
		.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) {return a === b}))
		.attr({
			d: mapPath,
			class: 'country-boundary'
		});

	//DRAW MAP LEGEND
	var legendContainerSize = d3.select('#legend').node().getBoundingClientRect()
	var rectWidth = legendContainerSize.width/color.range().length, rectHeight = legendContainerSize.height/2;
	console.log(rectWidth, rectHeight)
	var legend = d3.select('#legend').append('svg')
		.attr({
	          height: legendContainerSize.height,
	          width: legendContainerSize.width
	        })
	legend.append('g')
		.selectAll('rect')
		.data(color.range())
		.enter()
		.append('rect')
		.attr({
			x:function(d, i){return i * rectWidth},
			y: 0,
			height:rectHeight,
			width:rectWidth,
			fill: function(d){return d}
		})
		.style('stroke', 'white')
		.style('stroke-width', '0.6px')

	var legendText = bounds
	var legendLabels = legend.append('g')
		.selectAll('.legendLabels')
		.data(legendText)
		.enter()
		.append('text')
		.text(function(d){return Math.ceil(d)})
		.attr({
			x:function(d,i){return (i+1) * rectWidth},
			y: rectHeight + 1,
			class: 'legendLabels'
		})
		.style('alignment-baseline', 'hanging')
		
	//REDRAW FUNCTION
		//To-Do: Create a single function that responds to all the trigger events
	function redrawMapNUTS(mapFile, nutsData, groupID){
		filteredData = dataFilter(nutsData, true, groupID)
		//var test = uniq_fast(filteredData.map(function (d) {return d.regionCode})).sort()
		max = d3.max(filteredData, function(d) { return d.value; });
		min = d3.min(filteredData, function(d) { return d.value; });
		bounds = setBins(max,min);
		color.domain(bounds)


		mapKey = Object.keys(mapFile.objects)
		mapFeatures = topojson.feature(mapFile, mapFile.objects[mapKey]).features
		mapFeatures = addInditoMap(filteredData, mapFeatures)
		//console.log(mapFeatures.map(function(d){return d.properties.adminLevel}))
		turkeyMap.remove()
		turkeyMap = map.append('g').selectAll('.turkeyMap') //the large map with zone boundaries
			.data(mapFeatures)
			.enter()
			.append('path')
			.attr({
				d: mapPath,
				'class': 'turkeyMap',
				fill: function (d) {return color(d.properties.value)}
			})
			.style('cursor', 'pointer')
			.on('mouseover', mouseoverRegion)
			.on('mouseout', mouseoutRegion)
			.call(mapTip)
			//.on('click', onClickRegion);

		internalBoundaries.remove()
		internalBoundaries = map.append('path')
		internalBoundaries.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a !== b}))
		internalBoundaries.attr({
				d: mapPath,
				class: 'nuts-boundary'
			});
		countryBoundary.remove()
		countryBoundary = map.append('path')
		countryBoundary.datum(topojson.mesh(mapFile, mapFile.objects[mapKey], function(a, b) { return a === b}))
		countryBoundary.attr({
				d: mapPath,
				class: 'country-boundary'
			});
	}

/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

											//THE NEXT SECTION DRAWS THE SIDE PANEL
	//HELPER FUNCTION FOR GETTING DATA INTO GROUPS
	function groupData(nutsData, groups, region) { //region specifies the regional specification for the groups (so national or a particular hovered/clicked region)
		var data = dataFilter(nutsData, false, 2)
		var array = []
		groups.forEach(function(d) {
			var value = data.filter(function(e){return e.groupID === d.groupID && e.regionCode === region})[0].value
			array.push({
				mainGroup: d.mainGroup,
				subGroup: d.subGroup,
				groupID: d.groupID,
				value: value,
				// symbol:d.symbol,
				// fontSize: d.fontSize
			})
		})
		return array
	};

	//GET THE DATA INTO THE DIFFERENT GROUPS (HORIZ LINES) FOR THE SIDE PANEL
	var defaultRegion = "TR"
	var groupedData = groupData(nutsData, groups, defaultRegion); //the default region is set to national ("TR") for panel view
	console.log(groupedData)
	//GET THE CANVAS READY
	var panelContainerSize = d3.select('#panelContainer').node().getBoundingClientRect();
  	var panelMargin = {top: 0.08 * panelContainerSize.height , right: 0.08 * panelContainerSize.width, bottom: 0.008 * panelContainerSize.height, left: 0.2 * panelContainerSize.width};
  	var panelWidth = panelContainerSize.width - panelMargin.right - panelMargin.left; //Chart width
  	var panelHeight = panelContainerSize.height - panelMargin.top - panelMargin.bottom; //Chart height

  	var panel = d3.select('#panelContainer').append('svg') //http://bl.ocks.org/mbostock/3019563
        .attr({
          height: panelHeight + panelMargin.top + panelMargin.bottom,
          width: panelWidth + panelMargin.left + panelMargin.right
        })
        .attr("id", "panelSvg")
      	// .attr("transform", "translate(" + (panelMargin.left) + "," + (panelMargin.top)+ ")");//moving the origin to the point where it starts
      	//.call(makeResponsiveMap)

    //GET THE SCALES AND CHARTING FUNCTIONS READY
    var maxValue = d3.max(groupedData, function(d) {return d.value});
    var minValue = 0;
    var xScale = d3.scale.linear() //the xScale is set based on the values of the indicator
    	.domain([minValue, 1.2 * maxValue])
    	.range([0, panelWidth]);

    //CREATE THE X-AXIS
    var numberTicks = Math.floor((maxValue - minValue)/15); //shared with the grid
    var xAxis = d3.svg.axis()
    	.scale(xScale)
    	.orient('bottom')
    	.ticks(numberTicks)

    var xAxisLine = panel.append('g')
    	.attr('class', 'xAxis')
    	.call(xAxis)
    	.attr('transform', 'translate(' + panelMargin.left + "," + (panelHeight) + ")")
    	.style('cursor', 'default')

    function drawBars(groupedData) {
    	//DRAWING THE ELEMENTS
	    var mainCategories = uniq_fast(groupedData.map(function(d) {return d.mainGroup})).sort()
	    var barHeight = 9;
	    var barGap = 5;
	    var padding = 5;
	    var mainFont = 14;
	    var mainCategoryPosition = panelMargin.top

	    mainCategories.forEach(function(d, i) {
	    	//Draw the main category Label
	    	panel.append('text')
	            .attr('class','catLabel')
		        .text(d)
		        .attr({
		        	x: 0, //1.25 * panelMargin.left,
		        	y: mainCategoryPosition - mainFont - padding
		        })
		        .style('font-size', mainFont + 'px');
		    
	    	//Draw the sub category bars for the main category
	    	var data = groupedData.filter(function(e) {return e.mainGroup === d})
	    	panel.append('g')
	    		.selectAll('.bars')
	    		.data(data)
	    		.enter()
	    		.append('rect')
	    		.attr({
	    			height: barHeight,
	    			class: 'bars',
	    			width: function(e) {return xScale(e.value)},
	    			x: 0,
	    			y: function(e, j) {return j * (barHeight + barGap)},
	    			transform: 'translate(' + panelMargin.left + "," + mainCategoryPosition +')'
	    		})
	    		.style('fill','rgb(43,140,190)')

	    	//Draw the sub labels
	    	var labels = uniq_fast(data.map(function(d) {return d.subGroup}))
	    	panel.append('g')
	    		.selectAll('.subLabels')
	    		.data(labels)
	    		.enter()
	    		.append('text')
	    		.attr({
	    			width: panelMargin.left,
	    			x: panelMargin.left - padding,
	    			y: function(e, j) {return j * (barHeight + barGap)},
	    			class: 'subLabels',
	    			transform: 'translate(0,' + mainCategoryPosition + ')'
	    		})
	    		.text(function(d) {return d})
	    	

	    	//update the Y position
	    	mainCategoryPosition += data.length * (barHeight + barGap) + (2 * mainFont)
	    })
		var textLabels = d3.selectAll('.subLabels')[0]
		for(i = 0; i < textLabels.length; i++) {
			if(textLabels[i].getBBox().width > panelMargin.left - padding) {
				var len = textLabels[i].innerHTML.length
				while(textLabels[i].getBBox().width > panelMargin.left - padding){
					len--
					textLabels[i].innerHTML = textLabels[i].innerHTML.substring(0, len) + "..."
				}
			}
		}
    }

    drawBars(groupedData)


    //REDRAW FUNCTION FOR THE PANEL
    function redrawPanel(nutsData, groups, region){
    	//get the new data
    	groupedData = groupData(nutsData, groups, region)
    	
    	//update scales and axis
    	maxValue = d3.max(groupedData, function(d) {return d.value})
    	xScale.domain([minValue, 1.2 * maxValue])
    	numberTicks = Math.ceil((maxValue - minValue)/15)
    	xAxis.ticks(numberTicks)
    	xAxisLine.call(xAxis)

    	//update the chart
    	d3.selectAll('.bars')
    		.data(groupedData, function(d) {return d.subGroup}) //use the subGroup value to match the bars
    		.attr('width',function(d) {return xScale(d.value)})


    }

/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/


    									//LISTENERS FOR DIFFERENT TRIGGER EVENTS
	//1. CLICK ON THE RADIO BUTTONS: ONLY AFFECTS MAPS SINCE PANEL IS AFFECTED ONLY BY HOVER OR CLICK EVENTS ON MAP
	$('input:radio').on('click', function(e) {
		var nutsLevel = Number($("input[type='radio'][name='mapLevel']:checked").val())
		if (nutsLevel === 1) {
			mapFile = mapFile1
		} else if (nutsLevel === 2) {
			mapFile = mapFile2
		} else {
			mapFile = mapFile3
		}
		redrawMapNUTS(mapFile, nutsData, 2)
	});

	//2. A NEW INDICATOR SELECTION AFFECTS BOTH MAP AND PANEL
	d3.select('#indicatorList').on('change.line', function(d) {
		redrawMapNUTS(mapFile, nutsData, 2);
		redrawPanel(nutsData, groups, defaultRegion) //region is reset to the national level (so clicked or hovered regions are wiped)
    });

	//3. MOUSE-HOVER ON REGION
		//To-Do: Implement a smooth boundary transition that is attractive
	function mouseoverRegion(d) {
		var hoverRegion = d.properties.adminLevel;
		redrawPanel(nutsData, groups, hoverRegion)
		mapTip.show(d)
	}
	function mouseoutRegion(d) {
		redrawPanel(nutsData, groups, defaultRegion)
		mapTip.hide(d)
	}

	/*//4. MOUSE-CLICK ON REGION- implement only if necessary
		//To-Do: Execute an efficient and elegant toggle mechanism for clicked regions
	
	function onClickRegion(d) {
		if(d.properties.active) { //if the state is already active then toggle to nont-active
			d.properties.active = false;
		} else {
			d.properties.active = true;
		}
		console.log(d)
	}*/

	//5. PANEL DOT HOVER
	function mouseoverBar(d) {
		redrawMapNUTS(mapFile, nutsData, d.groupID)
		barTip.show(d)
	}

	function mouseoutBar(d) {
		redrawMapNUTS(mapFile, nutsData, 2)
		barTip.hide(d)
	}

}
	//Test: Automatically center map
/*	http://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object
	var b = [], west, east, south, north, bWidth, bHeight;
	for(i = 0; i < mapFeatures.length; i++) {
		b.push(mapPath.bounds(mapFeatures[i]));
	}
	west = d3.max(b.map(function(d) {return d[0][0]}))
	east = d3.max(b.map(function(d) {return d[1][0]}))
	south = d3.max(b.map(function(d) {return d[0][1]}))
	north = d3.max(b.map(function(d) {return d[1][1]}))

	bWidth = Math.abs(east - west);
	bHeight = Math.abs(north - south);
	console.log(mapWidth, mapHeight, bWidth, bHeight)
	var s = 0.9/Math.max((bWidth/mapWidth), (bHeight/mapHeight))
	var t = [(mapWidth - (s * bWidth)) / 2, (mapHeight - (s * bHeight)) / 2]
	console.log(s, t)
	mapProjection
		.scale(s)
		.translate(t)*/


</script>
</html>
